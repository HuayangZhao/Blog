/*
Navicat MySQL Data Transfer

Source Server         : mysql
Source Server Version : 50553
Source Host           : localhost:3306
Source Database       : blog

Target Server Type    : MYSQL
Target Server Version : 50553
File Encoding         : 65001

Date: 2018-11-11 23:54:30
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for articles
-- ----------------------------
DROP TABLE IF EXISTS `articles`;
CREATE TABLE `articles` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(255) NOT NULL,
  `content` text NOT NULL,
  `ctime` varchar(255) NOT NULL,
  `authorId` int(11) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=13 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of articles
-- ----------------------------
INSERT INTO `articles` VALUES ('8', '通过Session和cookie识别登陆用户及状态保持', '# Node.js\r\n\r\n##  cookie介绍\r\n### 什么是cookie，作用是什么\r\n+ 由于**Http协议是无状态**的，且传统服务器**只能被动的响应请求**，所以，当服务器获取到请求的时候，并不知道当前请求属于哪个客户端！\r\n+ 服务器为了能够明确区分每个客户端，需要使用一些小技术，来根据不同的请求区分不同的客户端；\r\n+ 只要有请求发生，那么必然对应一个客户端，我们可以在每次客户端发起请求的时候，向服务器自动发送一个标识符，告诉服务器当前是哪个客户端正在请求服务器的数据；\r\n+ 如何提供这个标识符呢？我们可以在请求头(Request Headers)中添加一个标签，叫做`cookie`，这样，每次发送请求，都会把这个cookie随同其他报文一起发送给服务器，服务器可以根据报文中的cookie，区分不同的客户端浏览器。\r\n+ 如何在客户端请求头中添加标识符？\r\n - 在Node中可以在`writeHeader`的时候，通过`Set-Cookie`来将cookie标识通过响应报文发送给客户端！\r\n - 客户端也可以通过一些方式来操作自己的cookie，比如通过`jquery.cookie`这个插件！\r\n\r\n### cookie的基本使用\r\n```js\r\nvar http = require(\'http\');\r\n\r\nvar server = http.createServer();\r\n\r\nserver.on(\'request\', function (req, res) {\r\n    // 解析cookie\r\n    var cookies = {};\r\n    var cookieStr = req.headers.cookie; // 从请求的headers中获取cookie信息\r\n    cookieStr && cookieStr.split(\';\').forEach(function (item) {\r\n        var parts = item.split(\'=\');\r\n        cookies[parts[0].trim()] = parts[1].trim(); // 将cookie解析出来，保存到对象中\r\n    });\r\n\r\n    res.writeHeader(200, {\r\n        \'Content-Type\': \'text/plain; charset=utf-8\',\r\n        \"Set-Cookie\": [\'issend=ok\', \'age=20\']\r\n    });\r\n\r\n    if(cookies.issend ===\'ok\'){\r\n        res.end(\'不要太贪心哦！\');\r\n    }else{\r\n        res.end(\'呐，赏你一朵小红花~~\');\r\n    }\r\n});\r\n\r\nserver.listen(4000, function () {\r\n    console.log(\'服务器已启动!\');\r\n});\r\n```\r\n\r\n### 通过`expires`设置Cookie的过期时间\r\n```js\r\n// 设置 过期时间 为60秒之后\r\n// 注意：在设置过期时间的时候，需要将时间转换为 UTC 格式\r\nvar expiresTime = new Date(Date.now() + 1000 * 60).toUTCString();\r\nres.writeHeader(200, {\r\n  \'Content-Type\': \'text/html; charset=utf-8\',\r\n  \'Set-Cookie\': [\'isvisit=true;expires=\' + expiresTime, \'test=OK\']\r\n});\r\nres.end(\'<h3>你好，欢迎光临，送给你一个苹果！</h3>\');\r\n```\r\n\r\n[GMT和UTC有什么区别？格林尼治标准时（GMT）与世界时（UTC）是怎么回事](http://www.wbiao.cn/cartier-watches/knowledge/article-1468.html)\r\n\r\n### cookie可以被伪造，不安全\r\n使用谷歌插件`edit this cookie`，就能伪造cookie数据！所以不要使用cookie存储敏感的数据！比如登录状态和登录信息；\r\n一些敏感的数据，应该存储都服务器端！\r\n\r\n### 什么是Cookie的应用场景\r\n1. 对安全性要求不高\r\n2. 不需要存储大量的数据\r\n3. 主要应用场景，是用来做 客户端 与 服务器之间的 状态保持技术；\r\n\r\n## 登录退出及状态保存\r\n\r\n### 使用`express-session`来保存登录状态\r\n#### 什么是session\r\n由于HTTP是无状态的，所以服务器在每次连接中持续保存客户端的私有数据，此时需要结合cookie技术，通过session会话机制，在服务器端保存每个HTTP请求的私有数据；\r\n\r\n####  session原理\r\n在服务器内存中开辟一块地址空间，专门存放每个客户端私有的数据，每个客户端根据cookie中保存的私有sessionId，可以获取到独属于自己的session数据。\r\n\r\n####  在express中使用session\r\n1. 安装session模块\r\n```bash\r\nnpm install express-session -S\r\n```\r\n2. 导入session模块\r\n```js\r\nvar session = require(\'express-session\')\r\n```\r\n3. 在express中使用`session`中间件：\r\n```js\r\n// 启用 session 中间件\r\napp.use(session({\r\n  secret: \'keyboard cat\', // 相当于是一个加密密钥，值可以是任意字符串\r\n  resave: false, // 强制session保存到session store中\r\n  saveUninitialized: false // 强制没有“初始化”的session保存到storage中\r\n}))\r\n```\r\n4. 将私有数据保存到当前请求的session会话中：\r\n```js\r\n// 将登录的用户保存到session中\r\nreq.session.user = result.dataValues;\r\n// 设置是否登录为true\r\nreq.session.islogin = true;\r\n```\r\n5. 通过`destroy()`方法清空`session`数据：\r\n```js\r\nreq.session.destroy(function(err){\r\n  if(err) throw err;\r\n  console.log(\'用户退出成功！\');\r\n  // 实现服务器端的跳转，这个对比于 客户端跳转\r\n  res.redirect(\'/\');\r\n});\r\n```\r\n\r\n\r\n\r\n\r\n## 相关文章\r\n1. [node.js中express-session配置项详解](http://blog.csdn.net/liangklfang/article/details/50998959)\r\n2. [MD5在线生成器1](http://www.cmd5.com/)\r\n3. [MD5在线生成器2](http://pmd5.com/)\r\n4. [JavaScript-MD5](https://github.com/blueimp/JavaScript-MD5)', '2018-11-08 21:23:36', '12');
INSERT INTO `articles` VALUES ('9', '加密算法', '## MD5 的特性\r\n\r\n1. **MD5 是一种加密算法**，在调用这个算法的时候，提供一个密码的明文， 调用的结果，得到一个 32 位长度的密文；\r\n2. **MD5 算法的特性：**相同的字符串，如果多次调用 md5 算法，得到的结果，完全一样；\r\n3. **MD5 算法，无法被逆向解密**；\r\n4. 但是，基于 md5 算法的第二个特性，我们可以进行碰撞暴力破解；（MD5 存在被暴力破解的安全性问题）\r\n5. 为了解决 简单的明文密码，被 md5 加密后，通过 暴力破解的安全性问题， 然后就出现了**加盐**的MD5加密；\r\n6. 目前，md5的暴力破解，又升级了，升级到了 `彩虹表`；\r\n7. 由于彩虹表出现，我们推荐大家，在存储网站密码的时候，使用 `bcrypt` 加密算法，得到加密之后的密文进行存储；\r\n\r\n\r\n\r\n## bcrypt 加密算法\r\n\r\n1. 在调用加密算法的时候，需要手动提供一个 `幂次`;\r\n2. 调用加密算法，得到的加密结果格式：`$版本号$循环的幂次$22位的随机盐 31位的密文`\r\n   + 加密的`随机盐`和`加密的幂次`，和`加密算法的版本号`已经被存储到了真正的密文中；\r\n\r\n\r\n\r\n## 项目中使用 bcrypt 的步骤\r\n\r\n1. 运行 `npm i node-pre-gyp -g` \r\n\r\n2. 在项目根目录中，打开终端，运行 `cnpm install bcrypt -S`\r\n\r\n3. 导入 `bcrypt` \r\n\r\n   ```js\r\n   // 导入加密的模块\r\n   const bcrypt = require(\'bcrypt\')\r\n   ```\r\n\r\n4. 定义幂次：\r\n\r\n   ```js\r\n   // 定义一个 幂次\r\n   const saltRounds = 10    // 2^10\r\n   ```\r\n\r\n5. 调用 `bcrypt.hash()` 加密：\r\n\r\n   ```js\r\n   // 加密的方法\r\n   bcrypt.hash(\'123\', saltRounds, (err, pwdCryped) => {\r\n      console.log(pwdCryped)\r\n   })\r\n   ```\r\n\r\n6. 调用`bcrypt.compare()`对比密码是否正确：\r\n\r\n   ```js\r\n   // 对比 密码的方法\r\n   bcrypt.compare(\'123\', \'$2b$10$i1ufUKnC9fXTsF9oqqvLMeDnpNfYIvhyqKRG03adiebNFPkjW3HPW\', function(err, res) {\r\n     console.log(res)\r\n     // 内部对比的过程：\r\n     // 1. 先获取 输入的明文\r\n     // 2. 获取输入的密文\r\n     // 2.1 从密文中，解析出来  bcrypt 算法的 版本号\r\n     // 2.2 从密文中，解析出来 幂次\r\n     // 2.3 从密文中，解析出来前 22 位 这个随机盐\r\n     // 3. compare 方法内部，调用 类似于 hash 方法 把 明文，幂次，随机盐 都传递进去     最终得到正向加密后的密文\r\n     // 4. 根据最新得到的密文，和 compare 提供的密文进行对比，如果相等，则 返回 true ，否则返回 false;\r\n   })\r\n   ```\r\n\r\n   ​\r\n## 使用模板引擎处理公共部分\r\n在PHP中，抽取公共的区域，直接使用PHP语法就行；\r\n但是，在Express的框架中，并没有抽取页面公共部分的语法，需要模板引擎提供这样的语法；\r\n\r\n\r\n## 添加文章并跳转到文章详情\r\n1. 发表文章之前，需要使用 第三方的插件，叫做 `markdown + editor` => `mditor`\r\n2. 注意：`mditor`这个第三方模块，提供了两个功能：\r\n + 功能1： 可以当作一个纯粹的MarkDown编辑器插件，在前端页面中使用；\r\n + 功能2： 在Node端，我们可以`require(\'mditor\')`，使用这个模块，提供的方法，把`markdown`文本，解析转换为`HTML`内容；\r\n\r\n## 相关文章\r\n1. [node.js中express-session配置项详解](http://blog.csdn.net/liangklfang/article/details/50998959)\r\n2. [MD5在线生成器1](http://www.cmd5.com/)\r\n3. [MD5在线生成器2](http://pmd5.com/)\r\n4. [JavaScript-MD5](https://github.com/blueimp/JavaScript-MD5)', '2018-11-09 21:34:49', '12');
INSERT INTO `articles` VALUES ('10', '获取参数的几种形式,Web开发模式及跨域', '## 1.express中获取参数的几种形式\r\n\r\n1. **获取 `http://127.0.0.1:3001/user?id=10&name=zs` 中的查询参数：**\r\n   + 直接使用 `req.query` 获取参数即可；\r\n   + 注意：URL 地址栏中通过 `查询字符串` 传递的参数，express 框架会直接解析，大家只需要使用 `req.query` 直接获取 URL 中 查询字符串的参数；\r\n2. **从URL地址中获取路径参数：**\r\n   + 假设后台的路由是 `app.get(\'/user/:id/:name\', (req, res) => {})`\r\n   + 假设客户端浏览器请求的URL地址为：`http://127.0.0.1:3001/user/10/zs`\r\n   + 直接使用 `req.params` 可以获取URL地址中传递过来的参数；\r\n3. **从post表单中获取提交的数据：**\r\n   + 借助于`body-parser`来解析表单数据\r\n   + **安装：**`npm i body-parser -S`\r\n   + **导入：**`const bodyParser = require(\'body-parser\')`\r\n   + **注册中间件：**`app.use(bodyParser.urlencoded({ extended: false }))`\r\n   + **使用解析的数据：** `req.body` 来访问解析出来的数据\r\n\r\n\r\n\r\n\r\n## 2 Web 开发模式\r\n\r\n### 2.1 混合模式（传统开发模式）\r\n+ 以后端程序员为主，基本上不需要前端程序员，或者，前端程序员只负责画页面、美化样式、写JS特效，前端程序员不需要进行数据的交互；\r\n+ 这种开发模式，在早些年比较常见；\r\n+ 传统开发模式下，用的最多的是 Jquery + 模板引擎 + Bootstrap\r\n+ 后端页面 .php   .jsp   .aspx   .cshtml\r\n### 2.2 前后端分离（趋势）\r\n+ 后端负责操作数据库、给前端暴露接口\r\n+ 前后端分离的好处：保证了各个岗位的职责单一；\r\n+ 前端负责调用接口，渲染页面、前端就可以使用一些流行的前端框架 Vue， React， Angular\r\n\r\n\r\n## 3. JSONP 和 CORS 的区别\r\n\r\n1. JSONP的原理：动态创建script标签；\r\n  + JSONP发送的不是Ajax请求\r\n  + 不支持 Post 请求；\r\n2. CORS中文意思是`跨域资源共享` ,需要服务器端进行 `CORS` 配置；\r\n  + CORS 发送的是真正的Ajax请求\r\n  + CORS 支持Ajax的跨域\r\n  + 如果要启用 CORS 跨域资源共享，关键在于 服务器端，只要 服务器支持CORS跨域资源共享，则 浏览器肯定能够正常访问 这种 CORS 接口；而且，客户端在 发送 Ajax的时候，就像发送普通AJax一样，没有任何代码上的变化；\r\n3. 对于Node来说，如果想要开启 CORS 跨域通信，只需要安装`cors`的模块即可；\r\n\r\n## 相关文章\r\n\r\n+ [跨域资源共享 CORS 详解](http://www.ruanyifeng.com/blog/2016/04/cors.html)\r\n+ [cors模块解决Node跨域资源共享问题](https://github.com/expressjs/cors)', '2018-11-09 21:39:00', '12');
INSERT INTO `articles` VALUES ('11', 'Node.js', '## 1. 使用 `nodemon` 工具来自动重启web服务器\r\n\r\n- **nodemon的作用**：能够**实时监听**当前项目中，文件的变化；只要监听到了文件的变化，则 nodemon 工具，会自动重新启动 web 服务器，从而使最新的代码生效；免去了程序员手动重启服务器的困扰；\r\n- **如何安装：**运行 `npm i nodemon -g`  全局安装即可；\r\n- **如何使用：**\r\n  - 之前使用 `node 要执行的文件路径` 来运行 Node.js 代码；\r\n  - 现在使用 `nodemon 要执行的文件路径` 来运行 Node.js 代码；\r\n- **注意：**今后在开发Web项目的时候，推荐使用 `nodemon` 来启动 web 服务器\r\n\r\n\r\n\r\n## 2. Node 中开发web项目的框架 - express\r\n\r\n> 定义（什么是Express）：一个快速的网站开发框架，封装了原生的http模块，用起来更方便；API更人性化\r\n\r\n\r\n\r\n### 2.1 express 框架的特点\r\n\r\n1. 基于Node.js平台之上，进一步封装了 `http` 模块，从而提供了更好用，更友好的 API\r\n2. 使用Express创建网站，比使用原生的http模块更加方便；\r\n3. Express 并没有覆盖 原生 http 模块中的方法，而是基于 原生方法之上，做了更友好的封装，让用户体验更好\r\n\r\n\r\n\r\n### 2.2 express 框架的安装和基本使用\r\n\r\n1. **安装：**运行 `npm i express -S` 即可安装\r\n2. **创建基本的 `express` 服务器：**\r\n   + 导入 `express` 第三方模块；\r\n   + **创建服务器的实例：**调用 `const app = express()` 方法；\r\n   + 通过 `app.get()` 或 `app.post()` 方法，来监听客户端的 `get` 或 `post` 请求，具体语法：\r\n     + **监听 `GET` 请求：**`app.get(\'请求地址\', (req, res) => { 处理函数 })` \r\n     + **监听 `POST` 请求：** `app.post(\'请求地址\', (req, res) => { 处理函数 })` \r\n   + **启动 express 服务器：**通过 `app.listen(端口, IP地址, 启动成功后的回调函数)` 启动服务器；\r\n\r\n\r\n\r\n\r\n### 2.3 express 中的快捷方法\r\n\r\n1. `res.send()`\r\n   1. 支持 发送 字符串 `Content-Type: text/html;`\r\n   2. 支持 发送 对象 或 数组 `Content-Type: application/json`\r\n   3. 支持 发送 Buffer 此时会当作文件下载；\r\n2. `res.sendFile()`\r\n   + 用法1：`res.sendFile(path.join(__dirname, \'./view/index.html\'))`\r\n   + 用法2：`res.sendFile(\'./view/movie.html\', { root: __dirname })`\r\n   + 注意：`res.sendFile()` 可以向浏览器发送 静态页面；\r\n\r\n\r\n\r\n\r\n### 2.4 使用 `express.static()` 快速托管静态资源\r\n\r\n>  如果我们网站中，有很多静态资源需要被外界访问，此时，使用 res.sendFile 就有点力不从心了;\r\n>\r\n> 这时候，express 框架，为我们提供了 `express.static(\'静态资源目录\')` \r\n>\r\n>  来快速托管指定目录下的所有静态资源文件；\r\n\r\n1. **语法1：** `app.use(express.static(\'public\'));`\r\n   - `app.use() `方法，是专门用来注册 中间件；\r\n   - `express.static` 是express的内置中间件；\r\n2. **语法2：**`app.use(\'/虚拟目录\', express.static(\'public\'))`\r\n\r\n\r\n\r\n\r\n### 2.5 为 express 框架配置模板引擎渲染动态页面\r\n\r\n1. 安装 ejs 模板引擎` npm i ejs -S`\r\n2. 使用 app.set() 配置默认的模板引擎 `app.set(\'view engine\', \'ejs\')`\r\n3. 使用 app.set() 配置默认模板页面的存放路径 `app.set(\'views\', \'./views\')`\r\n4. 使用 res.render() 来渲染模板页面`res.render(\'index.ejs\', { 要渲染的数据对象 })`，注意，模板页面的 后缀名，可以省略不写！\r\n\r\n\r\n\r\n\r\n### 2.6 在 express 中配置 art-template\r\n\r\n1. 安装 两个包 `cnpm i art-template express-art-template -S`\r\n\r\n2. 自定义一个模板引擎  `app.engine(\'自定义模板引擎的名称\', 渲染函数)`\r\n3. 将自定义的模板引擎，配置为 express 的默认模板引擎  `app.set(\'view engine\', \'具体模板引擎的名称\')`\r\n4. 配置 模板页面得存放路径 `app.set(\'views\', \'路径\')`\r\n\r\n\r\n\r\n## 3. 使用 express 框架中提供的路由来分发请求\r\n\r\n1. **什么是路由：**路由就是对应关系；\r\n2. **什么叫做后端路由：**前端请求的URL地址，都要对应一个后端的处理函数，那么 这种URL地址到 处理函数之间的对应关系，就叫做后端路由；\r\n3. 在Express中，**路由的主要职责** 就是 **把请求分发到对应的处理函数中**；\r\n4. 在Express中，如何 定义并使用路由呢？\r\n\r\n\r\n```js\r\n  // 1. 封装单独的 router.js 路由模块文件\r\n  const express = require(\'express\')\r\n  // 创建路由对象\r\n  const router = express.Router()\r\n\r\n  router.get(\'/\', (req, res)=>{})\r\n  router.get(\'/movie\', (req, res)=>{})\r\n  router.get(\'/about\', (req, res)=>{})\r\n\r\n  // 导出路由对象\r\n  module.exports = router\r\n```\r\n\r\n5. express 创建的 app 服务器，如何使用 路由模块呢？\r\n\r\n```js\r\n  // 导入自己的路由模块\r\n  const router = require(\'./router.js\')\r\n  // 使用 app.use() 来注册路由\r\n  app.use(router)\r\n```\r\n\r\n\r\n\r\n## 4. Express 框架里 中间件的概念\r\n\r\n### 4.1 什么是中间件\r\n\r\n> 定义：中间件就是一个处理函数；只不过这个函数比较特殊，包含了三个参数，分别是 `req`，`res`，`next`\r\n>\r\n> 注意：中间件方法中的三个参数：\r\n>\r\n> + req：请求对象；\r\n> + res：响应对象；\r\n> + next：next()可以被调用，表示调用下一个中间件方法；\r\n\r\n### 4.2 Express 框架中对中间件的5种分类\r\n\r\n1. **应用级别的中间件：** 挂载到 app 上的中间件 `app.get(\'URL地址\', （req, res, next）=> {})`；\r\n2. **路由级别的中间件：** 挂载到 router 对象上的中间件  `router.get(\'url地址\', (req, res, next)=>{})`\r\n3. **错误级别的中间件：** 回调函数中，有四个参数 `app.use((err, req, res, next)=>{})`\r\n4. **唯一内置的中间件：** `express.static()`\r\n5. **第三方中间件：** 非express框架提供的，需要程序员手动安装才能使用的中间件；`body-parser` 解析post 表单数据\r\n\r\n> 中间件的概念，了解即可，因为实际开发中，我们都直接使用第三方现成的中间件；\r\n\r\n\r\n## 5. 模块加载机制\r\n\r\n### 优先从缓存中加载\r\n\r\n+ 当一个模块初次被 `require` 的时候，会执行模块中的代码，当第二次加载相同模块的时候，会优先从缓存中查找，看有没有这样的一个模块！\r\n+ 好处：提高模块的加载速度；不需要每次都重新执行并加载模块！\r\n\r\n### 核心模块的加载机制\r\n\r\n+ 先查找缓存；如果缓存中没有，再去加载核心模块；\r\n\r\n### 用户模块的加载机制\r\n\r\n+ 先查找缓存；\r\n\r\n+ 如果缓存中没有则尝试加载用户模块；\r\n\r\n+ 如果在加载用户模块时候省略了后缀名，则：\r\n\r\n  ```\r\n  首先，严格按照指定的名称去查找\r\n  其次，尝试加载后缀名是 .js 的文件\r\n  如果没有.js的文件，则尝试加载 .json 结尾的文件\r\n  如果没有 .json 的文件，则尝试加载 .node 结尾的文件\r\n  查找规则：index  ->  index.js   ->   index.json   ->  index.node\r\n  ```\r\n\r\n  \r\n\r\n### 第三方模块的加载机制\r\n\r\n1. 先在项目根目录中查找`node_modules`文件夹\r\n2. 在`node_modules`文件夹下，查找模块相关的文件夹\r\n3. 在对应的文件夹下，查找`package.json`的文件\r\n4. 查找`package.json`文件中的`main`属性（指定了模块的入口文件）\r\n5. 如果找到了`main`属性，同时，`main`属性指定的文件路径存在，那么尝试加载指定的文件模块\r\n6. 加入没有`main`属性，或者`main`属性对应的文件不存在，或者没有`package.json`,那么会依次尝试加载`index.js`，`index.json`,`index.node`;\r\n7. 如果没有`index`相关的文件，或者没有指定模块对应文件夹，或者，当前项目根目录中没有`node_modules`文件夹，则向上一层目录中查找`node_modules`，查找规则同上！\r\n8. 最后，如果在项目所在磁盘的盘符根目录中，还找不到对应模块，则报错：`cannot find module ***`\r\n\r\n', '2018-11-09 21:42:45', '12');
INSERT INTO `articles` VALUES ('12', 'Node.js:同步和异步的概念,npm的基本使用', '## 1. Javascript 的单线程和异步\r\n\r\n> Javascript 的解析和执行一直是单线程的，但是**宿主环境（浏览器或node）**是多线程的；\r\n\r\n> 异步任务是由宿主环境开启子线程完成，并通过**事件驱动、回调函数、队列**，把完成的任务, 交给主线程执行;\r\n\r\n> Javascript解析引擎，一直在做一个工作，就是**从任务队列里提取任务，放到主线程里执行**。\r\n\r\n\r\n\r\n## 2. Node中的API为什么几乎都是异步操作\r\n\r\n1. 什么样的操作需要使用异步处理：要把 耗时的操作，放到异步中去执行；\r\n2. 异步执行任务的好处：能够提高 耗时的任务它的执行效率，提高 JS 解析引擎的工作效率；\r\n\r\n\r\n\r\n## 3. 认识模块化\r\n\r\n> 模块化就是一种约定，一定规范；\r\n>\r\n> 场景模拟：小强，小黄，小刚 共同基于 Node.js 开发项目！\r\n\r\n1. 为什么要有模块化：**为了解决文件之间的依赖关系**；\r\n2. 注意：**模块化是一种开发思想**；具体开发中需要定制符合实际需求的**模块化规范**！\r\n3. 大家可以把模块化规范，认为是一种**明文的约定**，大家都按照相同的约定写代码，减少了不必要的沟通成本，极大方便了各个模块之间的调用，方便别人，同时也方便自己；\r\n\r\n\r\n\r\n\r\n\r\n## 4. 了解 CommonJS 规范\r\n\r\n1. 作用：是一套 Javascript 的模块化规范，规定了 **模块的特性** 和 **各模块之间如何相互依赖**；\r\n2. 用途：Node.js 中使用了 CommonJS 规范；\r\n3. 特点：同步加载模块；不适合在浏览器端使用；\r\n4. CommonJS规范都定义了哪些内容：[wiki 对于 Modules 的描述](http://wiki.commonjs.org/wiki/Modules/1.1)\r\n\r\n\r\n\r\n\r\n\r\n## 5. 模块作用域 和 全局作用域\r\n\r\n> 在Node.js中有两个作用域，分别是 全局作用域 和 模块作用域；\r\n\r\n1. 全局作用域使用 `global` 来访问，类似于`浏览器中的window`；\r\n2. 每个 Javascript 文件，都是一个单独模块，每个模块都有自己独立的作用域，因此：模块中的成员，默认无法被其它模块访问。\r\n\r\n\r\n\r\n\r\n\r\n### 5.1 使用 global 全局作用域在模块之间共享成员\r\n\r\n1. 如果在某个模块内部，想为 全局的 global 作用域挂载一些属性，需要显示的调用`global.***`来挂载；\r\n2. 注意：在开发中，一般情况下，不推荐使用`global`全局作用域来共享成员，会存在全局变量污染问题；\r\n\r\n\r\n\r\n\r\n\r\n### 5.2 模块作用域\r\n\r\n1. **module（模块标识）**\r\n\r\n   module 属性是 Common JS 规范中定义的，它是一个对象，表示当前这个具体的 js 模块；\r\n\r\n2. **require（引用模块）**\r\n\r\n   每一个实现了 CommonJS 规范的模块，必须定义一个 require() 函数，使用这个 require 函数，就能够 很方便的导入其它 模块中的成员，供自己使用；\r\n\r\n3. **exports（暴露模块成员）**\r\n\r\n   每一个模块中，如果想要把自己的一些私有成员，暴露给别人使用，那么，必须实现一个 exports 对象，通过exports对象，可以方便的把模块内私有的成员，暴露给外界使用；\r\n\r\n\r\n\r\n\r\n\r\n### 5.3 module.exports 和 exports 的关系\r\n\r\n1. `module.exports` 和 `exports` 默认引用了同一个空对象；\r\n2. `module.exports` 和 `exports` 作用一致，都可以向外暴露成员；\r\n3. 一个模块作用域中，向外暴露私有成员时，永远以 `module.exports` 为准；\r\n\r\n\r\n\r\n\r\n\r\n## 6. 了解 - 浏览器端的 AMD 和 CMD 模块化规范\r\n\r\n> 注意：浏览器端不能使用 CommonJS规范；因为 CommonJS 下，模块是同步加载的；\r\n\r\n> AMD/CMD可以理解为是commonjs在浏览器端的解决方案，AMD/CMD下，模块都是异步加载的；\r\n\r\n1. AMD模块化规范代表：RequireJS\r\n   + 主要特性1：对于依赖的模块，AMD 是提前执行；\r\n   + 主要特性2：推崇依赖前置；\r\n2. CMD模块化规范代表：SeaJS\r\n   + 主要特性1：对于依赖的模块，CMD 是延迟执行；CMD 推崇 as lazy as possible.\r\n   + 主要特性2：推崇依赖就近；\r\n3. ES6的模块化（**大趋势**）：es6是在**语言标准层面上**，实现了模块功能，而且实现得相当简单，**完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案**；\r\n\r\n\r\n\r\n\r\n## 7. Node.js 中 `模块` 和 `包` 的概念\r\n\r\n> 回顾：Node.js 由三部分组成：ECMAScript 核心 + 全局成员 + 模块成员\r\n\r\n\r\n\r\n### 7.1 模块成员的分类\r\n\r\n> 模块成员，根据一些区别，又可以分为三大类： 核心模块、第三方模块、用户自定义模块\r\n\r\n\r\n\r\n#### 7.1.1 核心模块\r\n\r\n1. **什么是核心模块：**\r\n   + 随着Node.js的安装包，一同安装到本地的模块，叫做核心模块；\r\n   + 例如：`fs`，`path`等模块，都是由Node.js官方提供的核心模块；\r\n   + 只要大家在计算机中，安装了Node这个应用程序，那么，我们的计算机中就已经安装了所有的 核心模块；\r\n2. **如何使用核心模块**：`require(\'核心模块标识符\')`\r\n\r\n\r\n#### 7.2.2 第三方模块\r\n\r\n1. **什么是第三方模块：**\r\n    + 一些非官方提供的模块，叫做第三方模块；\r\n    + 注意，第三方模块，并不在我们的计算机上；\r\n    + 如果大家需要使用某些第三方模块，必须去一个叫做 `NPM` 的网站上搜索并下载才能使用；\r\n2. **如何使用第三方模块：**\r\n    + 先从 npm 官网上下载指定的第三方模块\r\n    + 使用 `require(\'第三方模块的名称标识符\')`来导入这个模块\r\n    + 根据 第三方模块的 官方文档，尝试使用\r\n\r\n\r\n#### 7.2.3 用户自定义模块\r\n\r\n1. **什么是用户模块：**\r\n   + 程序员在自己项目中写的 Javascript 文件，就叫做 用户自定义模块；\r\n2. **如何使用用户模块：**`require(\'路径标识符\')`\r\n\r\n\r\n\r\n\r\n### 7.2 包的定义和使用\r\n\r\n#### 7.2.1 什么是包\r\n\r\n1. 英文名叫做 `Packages`，包是在模块基础上更深一步的抽象；\r\n2. 包的目的：方便分发和推广基于 CommonJS 规范实现的 应用程序 或 类库；\r\n3. 包可以看作是 **模块**、**代码** 和 **其它资源** 组合起来形成的 独立作用域；\r\n\r\n\r\n\r\n\r\n#### 7.2.2 规范的包结构\r\n\r\n1. **包都要以一个单独的目录而存在**；\r\n2. **`package.json` 必须在包的顶层目录下**；\r\n3. **`package.json` 文件必须符合 JSON 格式，并且必须包含如下三个属性：`name`, `version`, `main`**\r\n    + **name**:  包的名字\r\n    + **version**: 包的版本号\r\n    + **main**: 表示包的入口文件\r\n4. 二进制文件应该在**bin目录**下;\r\n5. javaScript代码应该在**lib目录**下;\r\n6. 文档应该在**doc目录**下;\r\n7. 单元测试应该在**test目录**下;\r\n8. Node.js对包要求并没有那么严格，只要顶层目录下有`package.json`，并**符合基本规范**即可;\r\n\r\n\r\n\r\n\r\n#### 7.2.3 包描述文件 package.json【了解】\r\n\r\n```\r\nname：包的名称，必须是唯一\r\ndescription：包的简要说明\r\nversion：符合语义化版本识别规范的版本字符串\r\nkeywords：关键字数据，通常用于搜索\r\nmaintainers：维护者数组，每个元素要包含name、email、web可选字段\r\ncontributors：贡献者数组，格式与maintainers相同。包的坐着应该是贡献者数据的第一个元素\r\nbugs：提交bug的地址，可以是网址或者电子邮件地址\r\nlicenses：许可证数组，每个元素要包含type和url字段\r\nrepositories：仓库托管地址数组，每个元素要包含type、url和path字段\r\ndependencies：包的依赖，一个关联数组，由包名称和版本号组成。\r\ndevDependencies：开发依赖项，表示一个包在开发期间用到的依赖项\r\n```\r\n\r\n## 8. npm\r\n### 8.1 npm 的两层含义\r\n\r\n1. NPM 是一个 第三方模块的托管网站，指的就是`https://www.npmjs.com/`；\r\n2. NPM 是Node的包管理工具（全名叫做  Node package manager），在我们安装Node时候，就已经顺便也安装了 NPM 这个管理工具；\r\n\r\n\r\n\r\n### 8.2 安装和卸载全局包（i5ting_toc）\r\n\r\n1. **什么是全局的包：**安装到计算机全局环境中的包，叫做全局包；安装的全局包可以在当前电脑的任何目录下，直接通过命令行来访问；\r\n2. **如何安装全局包：**运行 `npm install 包名 -g` 即可；其中 `-g` 参数，表示 把包安装到全局目录中的意思；\r\n3. **全局包的安装目录：**`C:\\Users\\用户目录\\AppData\\Roaming\\npm`\r\n4. **什么样的包适合安装到全局：**工具性质的包，适合安装到全局；\r\n5. **如何卸载全局包：**要卸载某个全局的包，直接运行`npm uninstall 包名 -g`即可；其中 `uninstall` 表示卸载的意思；\r\n\r\n\r\n### 8.3 安装和卸载本地包\r\n\r\n1. **什么是本地的包：**跟着项目安装的包，叫做本地包；本地包都会被安装到 node_modules 目录下；\r\n2. **注意：**如果拿到一个空项目，**必须**在当前项目根目录中，先运行 `npm init`或者`npm init -y` 命令，初始化一个`package.json`的配置文件，否则包无法安装到本地项目中；\r\n3. **如何安装本地包：**运行`npm i 包名 --save` 即可安装本地包；都安装到了当前项目的 `node_modules`目录下；\r\n   + 如果大家用的是npm 5.x的版本，可以不指定`--save`命令，如果用的是 npm 3.x 的版本，则需要手动指定 `--save`；\r\n4. `package-lock.json`文件中记录了曾经装过的包的下载地址，方便下次直接下载包，能够加快装包的速度，提升装包的体验；\r\n5. **如何卸载本地包：**使用 `npm uninstall/remove 包名 -S/-D`即可卸载指定的本地包；\r\n\r\n\r\n### 8.4 其它常用命令\r\n\r\n1. `--save` 的缩写是 `-S`\r\n2. `--save-dev`的缩写是 `-D`\r\n3. `install` 的缩写是 `i`\r\n4. 注意：`dependencies` 节点，表示项目上线部署时候需要的依赖项；`devDependencies`节点，表示项目在开发阶段需要的依赖项，但是当项目要部署上线了，`devDependencies`节点中的包，就不再需要了！\r\n5. 注意：当使用 `npm i`快速装包的时候，npm会检查`package.json`文件中，所有的依赖项，然后都为我们安装到项目中\r\n6. `--production` 表示只安装 `dependencies` 节点下，记录的包，不安装`devDependencies`节点下的包；当项目要上线了，才会使用`--production`命令\r\n\r\n\r\n### 8.5 解决 npm 下载慢问题\r\n\r\n1. 默认，NPM在下载包的时候，连接的是国外的服务器，所以，有时候如果网速不是特别好，可能下载不下来包；此时，大家可以全局安装一个的工具，叫做 `cnpm`\r\n2. 如何安装`cnpm`：运行 `npm i cnpm -g` 即可；\r\n3. 如何使用`cnpm`：在装包的时候，只需要把 `npm` 替换成 `cnpm` 即可，例如：\r\n   + 使用 `npm` 安装 `jquery`：运行 `npm i jquery -S`\r\n   + 使用 `cnpm` 安装 `jquery`： 运行 `cnpm i jquery -S`\r\n\r\n\r\n## 9. 使用 Node 构建 web 应用\r\n\r\n1. PHP是后端的网站开发语言，PHP 开发出来的网站，可以通过 Apache 服务器托管运行起来；\r\n2. 疑问：Node中，可以使用 Javascript 编写后端网站，那么，有没有类似于 Apache 这样的服务器软件，来提供对应的网站服务呢？\r\n\r\n\r\n\r\n#### 9.1 B/S 交互模型\r\n\r\n> 什么是B/S：特指基于 浏览器（Browser） 和 服务器（Server） 这种交互形式；\r\n\r\n1. **什么是服务器：**在网络节点中，专门对外提供资源服务的一台电脑；\r\n2. **什么是客户端：**在网络节点中，专门用来消费服务的一台电脑；\r\n3. **HTTP 协议的通信模型：**`请求 - 处理 - 响应`的过程；\r\n   + 请求：由客户端发起请求；\r\n   + 处理：由服务器端处理请求；\r\n   + 响应：服务器端把处理的结果，通过网络发送给客户端；\r\n4. **什么是静态资源：**服务器端只需要读取并直接发送给客户端、不需要进一步处理的资源，叫做静态资源；\r\n5. **什么是动态资源：**服务器端没有现成的资源，需要服务器端动态生成的资源，叫做动态资源；\r\n\r\n\r\n\r\n\r\n#### 9.2 实现一个类似于Apache的 静态资源服务器\r\n\r\n> 使用`http`核心模块，创建最基本的`web服务器`\r\n\r\n1. **创建最基本的web服务器**\r\n\r\n   + **创建服务器：**使用 `const server = http.createServer()` 创建服务器；\r\n   + **绑定监听事件：**通过 `server.on(\'request\', function(req, res) { 请求的处理函数 })` 绑定事件 并 指定 处理函数；\r\n   + **启动服务器：**通过 `server.listen(端口, IP地址, 启动成功的回调函数)` 来启动服务器；\r\n\r\n2. **防止响应内容中文乱码问题**\r\n\r\n   + 通过  设置响应报文头的 `Content-Type`，来指定响应内容的编码类型，从而防止乱码：\r\n\r\n     ```js\r\n     res.writeHeader(200, { \r\n     	\'Content-Type\': \'text/plain; charset=utf-8\'\r\n     })\r\n     ```\r\n\r\n3. **根据不同的URL返回不同的文本内容**\r\n\r\n   - 使用 `req.url` 获取客户端请求的URL地址\r\n\r\n4. **根据不同的URL返回不同的HTML页面**\r\n\r\n   + 主要思路：使用 `fs 模块` 读取URL对应的HTML页面内容，并使用 `res.end()` 响应给客户端即可；\r\n\r\n\r\n\r\n## 相关文章\r\n+ [js模块化编程之彻底弄懂CommonJS和AMD/CMD！](https://www.cnblogs.com/chenguangliang/p/5856701.html)\r\n+ [把模块化彻底搞个明白（ES6模块/CommonJS/AMD/CMD）](https://github.com/zimplexing/zzZ/issues/23)\r\n+ [wiki 对于 Modules的描述](http://wiki.commonjs.org/wiki/Modules/1.1)\r\n+ [wiki 对于 Packages的描述](http://wiki.commonjs.org/wiki/Packages/1.1)\r\n+ [nodejs模块与包](http://blog.csdn.net/williamfan21c/article/details/54901974)\r\n+ [js的单线程和异步](http://www.cnblogs.com/woodyblog/p/6061671.html)', '2018-11-09 21:46:15', '12');

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(255) NOT NULL,
  `password` varchar(255) NOT NULL,
  `nickname` varchar(255) NOT NULL,
  `ctime` varchar(255) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=27 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES ('12', 'zhy', '123', 'zhy', '2018-11-08 19:31:27');
INSERT INTO `user` VALUES ('26', '测试1', '$2a$10$BRF82A9UvO8HKTTggmABKOV42nQzBcCjFhJNe0UmLL/nw.XrHid2a', '123456', '2018-11-11 23:52:16');
